# 오브젝트

<오브젝트>의 예제를 Go 언어로 따라해보기

## 진행방식

1. 각 소챕터마다 소개된 내용을 Go 언어로 작성하고 PR을 보낸다.
2. 참여자는 PR에서 Go언어에 맞는 코드에 대한 discussion을 진행한다.
3. discussion 내용을 요약해서 commit log에 추가한다
4. 모든 참여자가 동의를 하면 Merge!

각 소챕터마다 위와 같은 방식으로 진도를 나간다.

## 기대효과

> - Go 언어는 객체지향에 적합한 언어인가?
> - Go 언어는 복잡한 도메인 로직을 담아내는데 적합한 언어인가?

이 부분에 대한 답을 찾아보자!

## 진행상황

- [ ] 1-01. 티켓 판매 애플리케이션 구현하기
- [ ] 1-02. 무엇이 문제인가
- [ ] 1-03. 설계 개선하기
- [ ] 1-04. 객체지향 설계
- [ ] 2-01. 영화 예매 시스템
- [ ] 2-02. 객체지향 프로그래밍을 향해
- [ ] 2-03. 할인 요금 구하기
- [ ] 2-04. 상속과 다형성
- [ ] 2-05. 추상화와 유연성
- [ ] 3-01. 협력
- [ ] 3-02. 책임
- [ ] 3-03. 역할
- [ ] 4-01. 데이터 중심의 영화 예매 시스템
- [ ] 4-02. 설계 트레이드오프
- [ ] 4-03. 데이터 중심의 영화 예매 시스템의 문제점
- [ ] 4-04. 자율적인 객체를 향해
- [ ] 4-05. 하지만 여전히 부족하다
- [ ] 4-06. 데이터 중심 설계의 문제점
- [ ] 5-01. 책임 주도 설계를 향해
- [ ] 5-02. 책임 할당을 위한 GRASP 패턴
- [ ] 5-03. 구현을 통한 검증
- [ ] 5-04. 책임 주도 설계의 대안
- [ ] 6-01. 협력과 메시지
- [ ] 6-02. 인터페이스와 설계 품질
- [ ] 6-03. 원칙의 함정
- [ ] 6-04. 명령-쿼리 분리 원칙
- [ ] 7-01. 프로시저 추상화와 데이터 추상화
- [ ] 7-02. 프로시저 추상화와 기능 분해
- [ ] 7-03. 모듈
- [ ] 7-04. 데이터 추상화와 추상 데이터 타입
- [ ] 7-05. 클래스
- [ ] 8-01. 의존성 이해하기
- [ ] 8-02. 유연한 설계
- [ ] 9-01. 개방-폐쇄 원칙
- [ ] 9-02. 생성 사용 분리
- [ ] 9-03. 의존성 주입
- [ ] 9-04. 의존성 역전 원칙
- [ ] 9-05. 유연성에 대한 조언
- [ ] 10-01. 상속과 중복 코드
- [ ] 10-02. 취약한 기반 클래스 문제
- [ ] 10-03. Phone 다시 살펴보기
- [ ] 10-04. 차이에 의한 프로그래밍
- [ ] 11-01. 상속을 합성으로 변경하기
- [ ] 11-02. 상속으로 인한 조합의 폭발적인 증가
- [ ] 11-03. 합성 관계로 변경하기
- [ ] 11-04. 믹스인
- [ ] 11-01. 다형성
- [ ] 11-02. 상속의 양면성
- [ ] 12-03. 업캐스팅과 동적 바인딩
- [ ] 12-04. 동적 메서드 탐색과 다형성
- [ ] 12-05. 상속 대 위임
- [ ] 13-01. 타입
- [ ] 13-02. 타입 계층
- [ ] 13-03. 서브클래싱과 서브타이핑
- [ ] 13-04. 리스코프 치환 원칙
- [ ] 13-05. 계약에 의한 설계와 서브타이핑
- [ ] 14-01. 핸드폰 과금 시스템 변경하기
- [ ] 14-02. 설계에 일관성 부여하기
- [ ] 14-03. 일관성 있는 기본 정책 구현하기
- [ ] 15-01. 디자인 패턴과 설계 재사용
- [ ] 15-02. 프레임워크와 코드 재사용
